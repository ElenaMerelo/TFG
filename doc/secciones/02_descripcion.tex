\chapter{Descripci√≥n del problema}

The soccer analytics community is growing year after year. The potential of soccer data is not only catching the attention of researchers and amateur analysts but is also attracting more and more interest from soccer clubs. While the increased availability of freely available data and tools as well as the global pandemic led to an explosion of soccer analytics content in 2020, soccer clubs have arguably made a record-number of signings for data-related roles in 2021. Nevertheless, a significant number of high-quality blog posts and research papers has appeared in the past year. Like last year, this blog post provides an overview of the content that I liked the most!

As a result of the increased interest in soccer analytics, separating the wheat from the chaff has also become more challenging, especially for newcomers to the community. I keep track of the latest developments in the soccer analytics community primarily via Twitter, maintaining a list of soccer analytics people. This blog post lists my favorite soccer analytics content from the past year. If you believe your favorite research paper, blog post, webinar or podcast also deserves a spot in this review, then feel free to send me a direct message via Twitter or LinkedIn.

Me gusta jugar al f√∫tbol, estudio inform√°tica y matem√°ticas, con lo que 
surgen de manera natural preguntas en torno a la pr√°ctica de este deporte 
alrededor del cual gira todo un mundo, y la importancia de las decisiones 
que se van tomando tanto dentro como fuera del campo.

El an√°lisis del f√∫tbol no es para nada algo nuevo, y no es otra cosa que 
pensar, observar y reflexionar sobre lo que ocurre a lo largo de un partido 
o temporada(s), para actuar consecuentemente y, por ejemplo, fichar a 
ciertos jugadores en detrimento de otros, centrarse m√°s en la defensa 
que en el ataque, entrenar un tipo de jugada o pases espec√≠ficos, darle 
importancia a la t√°ctica o a la condici√≥n f√≠sica. La lista puede ser muy 
larga, tanto como los factores que, literalmente, entran en juego.

As√≠ pues, este proyecto tiene como idea ayudar desde los jugadores hasta 
el cuerpo t√©cnico del equipo: entrenadores, director t√©cnico, preparadores 
f√≠sicos y analistas t√°cticos (tambi√©n conocidos como 'scouting').

Dentro del an√°lisis de f√∫tbol, podemos entonces destacar los siguientes roles:

\begin{itemize}
    \item Analista t√°ctico: se encarga de estudiar los equipos y c√≥mo se desenvuelven en los diferentes partidos. Entre sus tareas se incluyen el an√°lisis del propio equipo y de los rivales.
    \item Scouter: es la persona encargada de la b√∫squeda y captaci√≥n de jugadores. Su tarea consiste en encontrar los jugadores que necesita el equipo o el club, por lo que analiza sus cualidades y posibilidades de integraci√≥n al equipo, desde su rendimiento futbol√≠stico hasta el econ√≥mico.
    \item Analista de datos: toma la informaci√≥n estad√≠stica de cada partido tanto en lo individual como en lo colectivo. Establece relaciones para encontrar respuestas o ideas que puedan colaborar con la toma de decisiones del club referentes a lo t√°ctico, lo t√©cnico y lo econ√≥mico, para el modelo de juego del equipo o para la compra y venta de jugadores.
\end{itemize}
Manteniendo esto en mente, nuestra soluci√≥n 
podr√≠a ser usada por ellos. Vemos entonces 
que el trabajo se puede enfocar de diversas 
maneras, y conforme avancemos habremos de descartar algunas y 
quedarnos con otras, quedando todo debidamente justificado. Depender√° de los 
datos que se encuentren disponibles, y la necesidad que haya en el mercado. 
Normalmente y si consultamos la literatura, los an√°lisis son est√°ticos; 
rendimiento y mapas de calor de un jugador, desde d√≥nde se ha lanzado m√°s 
a porter√≠a, etc. pero no hay tanto estudiado en cuanto a causalidad.

Llev√°ndolo un poco a tierra y como motivaci√≥n principal del presente proyecto,
\textbf{mi cliente como jugador aficionado me ha planteado muchas veces por qu√© 
 no se usa alg√∫n tipo de an√°lisis para, dadas las personas que se presentan 
 a un partido, hacer r√°pidamente unos equipos que est√©n equilibrados, y en 
 los que cada uno tenga una posici√≥n en la que est√©n c√≥modos y asegure un 
 buen resultado, as√≠ como que los cambios est√©n claros y se puedan hacer 
 sin perder tiempo.}


\section{Glosario de t√©rminos}
\subsection{Team Expected Goals}
Not all shots are equal ‚Äî a shot closer to the goal is obviously more 
valuable than a shot farther from goal.

Expected goals (xG) puts a number to the quality of a shot. A shot that has 
a 50\% chance of going in has an xG of 0.5. A shot with a 10\% chance of going 
in has an xG of 0.1. Adding up the xG of the shots a team takes is their ‚ÄúxG 
for‚Äù (xGF), and adding up the xG of the shots the team allows is their ‚ÄúxG 
against‚Äù (xGA). xGF minus xGA equals the ‚ÄúxG difference‚Äù, or xGD. Each data 
provider has their own formula for actually calculating xG, but all typically 
include information like the distance from and angle to goal, and what sort 
of scenario the shot came from (a cross or a set piece, for example).

Expected goals are a widespread and important metric in analytics. Teams 
that get more and better shots than their opponents tend to perform well in 
the long run, even if those shots don‚Äôt always go in, so xGD can be a better 
measure of team strength than just goal difference. 

\subsection{Player Expected Goals}
Players that get many high quality shots tend to score lots of goals. A 
player‚Äôs ability to get shots from good locations is actually a more 
important factor in scoring than his ability to finish chances from any 
location. Though analytics frequently confirm what people within soccer 
intuitively know, this is one example where statistics contradicts 
prevailing soccer wisdom.

\subsection{Goalkeeper Expected Goals}
For goalkeepers, xG relates to how difficult a save is. A keeper‚Äôs ‚Äúgoals 
saved above expected‚Äù measures shot-stopping ability ‚Äî how many more goals 
did a keeper save than an average keeper would have.

\subsection{Possession value}
Expected goals are a good measure for the chances that a team creates and 
concedes, but they‚Äôre only recorded when a team takes a shot. Possession 
value, though, calculates the probability of a goal being scored at any 
point in a possession. Just like with shots, a team on the ball right 
outside the box is much more dangerous than a team knocking it around in 
its own half ‚Äî this is why straight percentage of possession stats can be 
misleading. Possession value models that danger.

Much of analytics focuses on determining the actions that lead to higher 
and lower value possessions. Possession value provides a framework for evaluating the ways teams play, 
and it has led to interesting analyses of different parts of the game.

\subsection{Defensive actions}
Unlike offensive ability, defensive ability is incredibly difficult to 
evaluate from a possession value framework.

Generally, defensive statistics are adjusted for possession. 
A team with less possession has more opportunities to make defensive plays, 
so measures of their actions are adjusted accordingly. Passes per defensive 
action (PPDA) is one popular metric to measure the extent of a team‚Äôs press. 
Pressure on the ball is also used. Looking at where a team chooses to 
pressure the ball or make tackles and interceptions can be used to describe 
a team‚Äôs defensive set up: Are they a low block or high block? Do they 
press out wide or in the middle of the field?

\subsection{Passing ability}
Similar to measuring the quality of a shot (with xG), analytics can model 
the difficulty of a pass. Completing a pass into an opponent‚Äôs six-yard box 
is much more difficult than hitting a pass between two center backs, 
for example. Passing scores measure which players are able to hit passes 
at rates above what would be expected.

\subsection{Game states}
‚ÄúGame state‚Äù is a catch-all term for the condition of the game ‚Äî is a team 
winning, tied, or trailing? Are they home or away? Are they a man up or a 
man down? Game state effects provides important context for understanding 
statistics. Home-field advantage in MLS is very strong, and home teams 
take more shots, score more goals and win more often.

As a result, a team that starts the season with two months of road 
games (like Portland or D.C. United in the last two years) will look worse 
relative to the rest of the league. Teams on the road tend to play with a 
deeper defensive line and less possession, so stylistically, they might 
look like they play in a very deep block for those first two months.

\section{Visualizations}
Data visualization can also fall under the domain of analytics. Here are some 
popular ones:

\textbf{xG maps} show the value and location of the shots a team or player creates or 
concedes, either within a game or across a season.

\textbf{Passing networks} describe passing connections ‚Äî who passes to who, 
and where ‚Äî in order to understand how a team plays.

\textbf{Radars} and \textbf{bar charts} display a team‚Äôs or player‚Äôs 
performance across different metrics.

\textbf{Pass sonars} describe the passing tendencies and abilities of players.


\section{Metodolog√≠a}

Desarrollo √°gil
Planteamiento
Con el t√©rmino desarrollo √°gil se agrupan una serie de buenas pr√°cticas en el sector de la inform√°tica que ayudan a conseguir productos de calidad, adaptados a las necesidades de los clientes, y flexibles. En esta sesi√≥n veremos en qu√© consiste el desarrollo √°gil.

Al final de esta sesi√≥n
Se entender√° qu√© es el desarrollo √°gil, y se empezar√° a organizar el trabajo para emprender el desarrollo de un proyecto dentro de los t√©rminos del curso.

Criterio de aceptaci√≥n
Se habr√° asimilado en qu√© consiste el desarrollo √°gil, y diferentes t√©cnicas y herramientas usadas en ella, y se habr√° comenzado a elaborar una √©pica de la cual surgir√°n las historias de usuario que se vayan a usar m√°s adelante.

Desarrollo √°gil
Hace ahora 20 a√±os, el manifiesto √°gil apostaba por una nueva manera de entender el desarrollo de software que aportara valor al cliente y que fuera √°gil en la evoluci√≥n del mismo, a la vez que proporcionara un entorno de trabajo m√°s satisfactorio para quien lo desarrolla.

Este manifiesto ten√≠a una serie de lemas, que en general se presentaban en contraposici√≥n al m√©todo de cascada o waterfall en el que las diferentes fases de desarrollo estaban aisladas y diferenciadas, y s√≥lo se pasaba a producci√≥n al final de una larga cadena de departamentos aislados entre s√≠. Los principales lemas eran

Menos documentaci√≥n, y m√°s c√≥digo funcionando. La documentaci√≥n excesiva en forma de contratos y especificaciones funcionales no sirve de nada si no se acompa√±a de c√≥digo que funcione; el c√≥digo funcionando es la mejor forma de asegurar que efectivamente se entienden correctamente los requisitos del cliente.
Menos procesos, m√°s interacci√≥n con el cliente (y de los programadores entre s√≠). En vez de compartimentos aislados, con una cascada y el cliente en ambos extremos, las interacciones del cliente deben ser constantes, y los diferentes grupos de programadores llevando a cabo ese programa interaccionan continuamente para llevar el c√≥digo a un estado en el que se pueda mostrar al cliente.
La colaboraci√≥n del cliente no debe ser mediante contratos (aunque tendr√° que haberlos, sino mediante una interacci√≥n continua donde se le muestre productos funcionando y el cliente vea si eso corresponde a sus expectativas o no; si no lo hace, debe de organizarse el equipo de forma √°gil para evolucionar el producto hasta que lo haga.
Estos lemas se organizan en una serie de principios, doce en total. Pero de ellos vamos a extraer unos cuantos:

La programaci√≥n tiene que centrarse en resolver problemas. Lo m√°s importante es eso, y debe ser el principal enfoque de la tarea. Resolverlos, y tener m√©todos √°giles para comprobar que efectivamente se ha resuelto.
Para interaccionar con el cliente y que vea esos productos m√≠nimamente viables, hay que publicar frecuentemente, pasando a producci√≥n cualquier cosa que est√© lista y pase todos los tests. En este sentido, se parece al release early, release often del mundo del software libre.
El dise√±o es esencial, aunque dentro de los l√≠mites de que se prefiere el c√≥digo a la documentaci√≥n. El dise√±o previo a la codificaci√≥n debe seguir todos los lemas y todos los principios √°giles.
Hay que atenerse a las buenas pr√°cticas para codificar, en todas las √°reas del proyecto, desde c√≥mo nombrar las variables hasta que‚Äôtipo de herramientas y metodolog√≠as se consideran las mejores en un momento determinado. Es decir, cuando se comience un proyecto debe de dedicarse cierto tiempo a establecer cuales son esas buenas pr√°cticas. En la evoluci√≥n del mismo, ser√° esencial para su flexibilidad y comprensibilidad seguir las mismas.
La simplicidad es esencial, y no se debe hacer m√°s que lo que hay en los requisitos, ni buscar m√°s caracter√≠sticas que las que estrictamente se necesiten para resolver un problema.
El trabajo se debe revisar frecuentemente, con el objetivo de hacerlo m√°s eficiente, adaptarlo a nuevos requisitos, o simplemente incorporarlo a producci√≥n; el c√≥digo siempre debe haber pasado por varios ojos antes de que sea h√°bil para funcionar.
Estos principios deben guiar una metodolog√≠a de trabajo. Para empezar, dice que hay que empezar por un problema a resolver, no con qu√© se quiere hacer. Las soluciones no pueden estar por delante del problema. Es decir, empezar por decir las herramientas que se van a usar para hacer algo es una forma de empezar algo que no va a ser simple, posiblemente no resuelva ning√∫n problema, y sea dif√≠cil de probar si efectivamente funciona o no. Adem√°s, te indica que hay que organizar el trabajo en hitos, cada uno de los cuales implicar√° la publicaci√≥n de un producto m√≠nimamente viable, cada uno de los cuales se construir√° sobre el anterior (o se agregar√° al anterior, seg√∫n el problema). Sin un producto m√≠nimamente viable, no se puede testear, y sin tener claro qu√© problema se quiere resolver, tampoco.

La calidad en el software empieza por el dise√±o, y este dise√±o incluye desde la modularizaci√≥n del problema, hasta el el uso de lenguaje, bibliotecas o estructuras de datos para trabajar. En inform√°tica rara vez hay una sola forma de hacer las cosas, y siempre hay que tomar decisiones t√©cnicas que tendr√°n implicaciones en la evoluci√≥n del software. Dise√±ar te va ayudar a escribir menos c√≥digo, y el mejor c√≥digo es el que no hay que testear, con lo que ser√° c√≥digo de m√°s claridad. Un dise√±o flexible, por capas, que desacople diferentes partes del mismo, ser√° tambi√©n mucho m√°s f√°cil de adaptar a diferentes circunstancias.

Y la b√∫squeda de mejores pr√°cticas es esencial. La sintaxis y los manuales de referencia, y los tutoriales, rara vez se preocupan de guiar en la toma de una serie de decisiones t√©cnicas. Te presentan una soluci√≥n como ideal, o posiblemente la √∫nica posible. Sin embargo, llegar a esas soluciones implica una serie de decisiones, y es en las que hay que seguir las mejores pr√°cticas, a todos los niveles: personales, empresas, industria.

Finalmente, se tiene que establecer una infraestructura para revisi√≥n de c√≥digo. Lo m√°s simple es establecer un est√°ndar en el cual no se incorpore c√≥digo a la rama principal directamente, sino que se haga siempre mediante pull requests. Pero adicionalmente, el desarrollo √°gil pide la creaci√≥n de una serie de reuniones, normalmente llamadas retro, que revisan el c√≥digo que ha puesto en producci√≥n, y sugiere, siempre de forma constructiva, diferentes mejoras (que se incorporar√°n a un MVP futuro). El pasar tests frecuentemente para guardarse de posibles cambios en las dependencias tambi√©n es una buena pr√°ctica, porque cerrarse en una versi√≥n determinada de todo puede ser eficiente a la hora de llevar a producci√≥n, pero las versiones de todo acaban siendo deprecadas y no quieres encontrarte en una situaci√≥n en la cual tengas que reescribir todo por usar algo con posibles huecos de seguridad.

Capturando los deseos de los clientes
Los deseos de los clientes se capturar√°n en unas historias de usuario. Pero previo a las historias de usuario se tendr√°n que crear unas narrativas de los diferentes pasos que van a dar los diferentes tipos de usuario, una visi√≥n m√°s global que, m√°s adelante, se dividir√° en fragmentos, historias de usuario, testeables y programables. Estas narrativas se llaman √©picas. En general, como afirma en el enlace anterior:

Son historias de usuario demasiado extensas que se tienen que dividir en otras m√°s peque√±as.

Y en este punto es donde es conveniente empezar a usar las mejores pr√°cticas en el desarrollo √°gil. Hay muchas formas de llevarlo a cabo, pero generalmente se agrupan en dos campos diferentes: los partidarios de usar scrum o los usuarios de kanban. Hay diferencias considerables, aunque los dos coinciden en el hecho de que se trabaje sistem√°ticamente con historias de usuario‚Ä¶ y con un tablero. Los tableros permiten ver claramente en qu√© estado est√° el trabajo, y permite organizar las historias de usuario en diferentes columnas seg√∫n el estado en el que est√©n. Las columnas cl√°sicas son ‚ÄúPor hacer‚Äù, ‚Äúhaci√©ndose‚Äù y ‚Äúhecho‚Äù, pero se pueden a√±adir otras columnas seg√∫n el proyecto y el equipo: Dise√±o t√©cnico, o Tormenta de Ideas. Estas √∫ltimas permiten interaccionar, a trav√©s de la herramienta que se elija (que, por simplicidad, es mejor que sea la que provee el gestor de c√≥digo, por ejemplo, el de GitHub).

Estas columnas de ‚Äútormenta de ideas‚Äù se pueden usar, por ejemplo, para elaborar colaborativamente una √©pica. De esa √©pica, posteriormente, surgir√°n las diferentes historias de usuario. Pero eso lo veremos a continuaci√≥n.

Respetando los deseos de los clientes de forma incremental: milestones
Como la metodolog√≠a √°gil aboga por presentar frecuentemente los resultados al cliente para ver si corresponde a sus expectativas, y cambiar o adaptar los requerimientos como resultados de las mismas, por lo que el desarrollo de un producto se debe hacer de forma incremental como una serie de entregables, cada uno de ellos apoyado en el anterior, con complejidad creciente y tambi√©n un acercamiento creciente al cumplimiento de las historias de usuario (que, en muchos casos, no se podr√°n cumplir hasta el producto final).

Todo el desarrollo tiene que organizarse alrededor de estos entregables, como si fueran mojones en una carretera (o milestones). La met√°fora es que uno va avanzando por la carretera, hasta llegar al destino final, que es un producto que satisface una cantidad aceptable de historias de usuario (y puede, por tanto, ser desplegado o subido a un app store o simplemente una versi√≥n nueva en una biblioteca).

Los milestones, por tanto, tienen que cumplir estas caracter√≠sticas

Tiene que estar ordenados en una progresi√≥n l√≥gica, que incluya todas las etapas del desarrollo, o al menos todas las que terminen en c√≥digo en el repositorio.
Cada milestone tiene que describir un producto m√≠nimamente viable. El producto m√≠nimamente viable tiene que ser m√°s complejo que el anterior, incluirlo y agrupar todo el desarrollo hecho desde el entregable anterior.
Que sea m√≠nimamente significa que s√≥lo va a incluir lo estrictamente necesario para que funcione; y que sea viable indica que tiene que ser un producto real, con un criterio de aceptaci√≥n, y no una simple agrupaci√≥n de tareas no relacionadas entre s√≠. Estos tests, casi siempre, estar√°n automatizados, aunque en la realidad la viabilidad tendr√≠a que decidirla el equipo de producto en contacto con los clientes.
Tambi√©n tiene que ser un producto en el sentido que sea algo con entidad propia, desde el dise√±o de una clase con c√≥digo que compile hasta una aplicaci√≥n cliente-servidor completa publicada en un store para las mismas.
Como siempre se va a desarrollar para el siguiente PMV, todo desarrollo que se haga tendr√° que fluir desde las historias de usuario, pasando por issues que lo desarrollen, hasta los productos m√≠nimamente viables, que tambi√©n incluir√°n a los pull requests que agrupen una serie de issues. Las historias de usuario, en general, podr√°n irse moviendo de un milestone al siguiente, seg√∫n se vayan implementando, o simplemente dejarse fuera de los milestones; los issues siempre tendr√°n que estar en un milestone. Evidentemente, como se va avanzando por una carretera, en general s√≥lo se estar√° trabajando en un PMV.

Por la misma raz√≥n, no es necesario planificar desde el principio todos los milestones que se vayan a desarrollar, s√≥lo una cantidad suficiente para tener claro el horizonte al que se avanza; seg√∫n se vaya desarrollando, se ver√° la necesidad de crear nuevos milestones, con releases que pueden ser internas (para el propio equipo) o externas (para el cliente).

Los PMVs pueden ser internos o externos. En general, son un punto de control para pararse y decir ‚Äú¬øEs esto lo que queremos/quiere el cliente?‚Äù. Tambi√©n es una forma tangible del desarrollo, puesto que es algo que se puede liberar o publicar. Por eso tambi√©n se suele establecer un tag para el repositorio con cada uno de los PMVs, que establezcan claramente cu√°l era el punto en el desarrollo. A ese punto se puede volver, por ejemplo, para corregir errores o simplemente volver a √©l si alg√∫n PMV posterior no es viable.

1. Motivaci√≥n/problema que quer√©is resolver. ¬øPor qu√© quer√©is hacer este TFG? ¬øA qui√©n ayuda? ¬øQui√©n lo usar√≠a? ¬øQu√© soluci√≥n propon√©is? La ingenier√≠a del software trata de resolver problemas, no de hacer aplicaciones, y los problemas deben estar antes que nada.
2. De la motivaci√≥n saldr√°n los objetivos que os plante√°is (y de los objetivos una serie de productos m√≠nimamente viables, claro). Recordad mi art√≠culo sobre c√≥mo formular objetivos que os lo he puesto miles de veces.

Buenas. Parece que algunos est√°is poni√©ndoos m√°s en serio con el TF*, as√≠ que unos cuantos consejos.
1. Tratad de usar el desarrollo √°gil tanto para la parte m√°s de rollete (o la matem√°tica) como para la parte m√°s de desarrollo. Lo que viene a continuaci√≥n viene de ah√≠.
2. Plantead una serie de milestones/PMVs de forma que en cada parte del camino teng√°is algo que entregar, y tambi√©n la documentaci√≥n correspondiente. Plantead plazos razonables para los mismos.
3. En muchos casos tendr√©is que plantear historias de usuario; en general, sirven siempre porque te centran en los problemas que quieres solucionar y los objetivos que quieres alcanzar. Las historias de usuario est√°n relacionadas con la l√≥gica de negocio de vuestro proyecto (y ten√©is que tener claro cu√°l es esta) y siempre son un beneficio para el usuario (los posibles usuarios del proyecto)
4. Los issues siempre plantean un problema. Siempre est√°n enmarcados en un milestone, y siempre tienen que tener un criterio de aceptaci√≥n para ser cerrados. 
5. Intentad que todo el c√≥digo se incorpore mediante PRs, y dejad los PRs un tiempo para darme tiempo a mi (y al cotutor en su caso) a comentar. Si veis uno especialmente complicado, pasadlo tambi√©n por aqu√≠ que los anteriores trabajofindecarrerantes (y los de esta hornada) igual os podr√°n echar una mano.

la secuencia ser√≠a:
Objetivos del TFG ‚Üí Milestones ‚Üí Issues que vayan desarrollando los PMVs ‚Üí PRs que vayan avanzando esos issues (y cerrando).

Recordad que siempre la secuencia es objetivos ‚Üí personas (clientes) ‚Üí historias de usuario ‚Üí milestones ‚Üí a programar.

Tambi√©n recordatorio de los 2-3 primeros milestones:
Milestone 0: Repo configurado con correcci√≥n ortogr√°fica, memoria comenzada con objetivos y motivaci√≥n, metodolog√≠a (es decir, todo esto de los milestones, √°gil, DDD, explicado). Tambi√©n configuraci√≥n global, gestor de tareas (makefile o lo que us√©is), etc√©tera.
Milestone 1: Identificaci√≥n de las estructuras de datos fundamentales y de los elementos principales de la l√≥gica de negocio, y programaci√≥n de los mismos. Este PMV ser√° una biblioteca con m√≠nima funcionalidad y todos los tests pasando. En los proyectos m√°s de investigaci√≥n, alternativamente ser√≠a crear el cap√≠tulo del estado del arte. (Y este ser√≠a el posterior). Estos dos son milestones internos
Milestone 2: A partir de aqu√≠ ya empezar√©is a hacer la aplicaci√≥n externa: API, cliente Telegram, alimentaci√≥n de la librer√≠a, descarga de datos reales, lo que sea. Ser√° un poco m√°s espec√≠fico de vuestro  TFG.

Una regla del pulgar para las historias de usuario: Siempre tienen que expresar un deseo y un beneficio para el usuario. Si pones "ojal√° qu√©" y te lo imaginas en la boca del usuario y suena cre√≠ble, es que es una historia de usuario. Si no, pues no.
üëâüèº "Ojal√° que pueda iniciar sesi√≥n y registrarme" ¬øSuena cre√≠ble? ¬øNo? Pues no es una historia de usuario, es un issue o tarea que t√∫ necesitas que el usuario haga para que cumpla sus deseos.

Os recuerdo que parte integral del TFG es saber organizar bien el desarrollo del mismo. Y esto no solamente por el tribunal (que tambi√©n), sino simplemente por vuestra salud mental y f√≠sica, y para optimizar la experiencia de aprendizaje que es lo que es un TFG. El objetivo del TFG no es hacer el TFG, sino aprender a gestionar un proyecto siguiendo las mejores pr√°cticas.

La memoria suele empezar con los objetivos (tras un breve paso por la motivaci√≥n/problema); no siempre es as√≠, pero as√≠ deber√≠a ser. El primer cap√≠tulo debe empezar por la motivaci√≥n (‚ÄúPor razones legales, en una serie de locales se necesita saber en tiempo real cuantas personas se encuentran en el mismo, as√≠ como tener un hist√≥rico‚Äù) y el planteamiento del problema (‚ÄúSe necesita un sistema de medici√≥n autom√°tica del aforo y de la duraci√≥n de la estancia de una persona en un recinto cerrado‚Äù), pero a continuaci√≥n, se deben experesar cuales son los objetivos del trabajo, es decir, qu√© parte de ese problema vamos a dejar resuelta y cu√°l se va a dejar como trabajo futuro.

Construir un sistema tal como el que a priori se va a necesitar (que iremos concretando durante el trabajo) implica ver qu√© componentes, partes o productos m√≠nimamente viables van a ser necesarios durante su desarrollo; tambi√©n ver cuales son los casos de uso reales. Por ejemplo, puede que sea un s√≥lo local en cuyo caso la soluci√≥n ser√° relativamente f√°cil: algo que se ejecute en un dispositivo en el mismo local. Pero puede ser un local con muchas estancias; o pueden ser muchos locales separados f√≠sicamente. Los objetivos deben estar claros, porque de los objetivos saldr√°n los casos de uso (una vez m√°s, los casos de uso son muy importantes) y de los casos de uso los hitos y tareas para resolverlos. Por ejemplo, puede ser el siguiente objetivo.

Crear un sistema que se pueda conectar a un sistema inform√°tico existente y que sea capaz de contar el n√∫mero total de personas en un local as√≠ como tiempo de permanencia, con el sistema costando menos de 30‚Ç¨ en total.
Los objetivos deben ser alcanzables, y en lo posible cuantitativos. En este caso, nos hemos comprometido a que valga menos de 30‚Ç¨ (lo que puede excluir, por ejemplo, equipos del tipo Raspi). Pero en subobjetivos se puede ir m√°s all√°.

Subobjetivos
Debe ser capaz de contar en recintos de x metros cuadrados.
Debe contar el n√∫mero de personas con una resoluci√≥n de 5 minutos.
En el primer caso, va a ser totalmente diferente la soluci√≥n dependiendo de la dimensi√≥n del recinto; el segundo nos va a dar un l√≠mite en la capacidad de procesamiento del sistema. Que en este caso es amplia, pero puede ser de 1 segundo, en cuyo caso habr√° que compon√©rselas.

No ser√° un objetivo, por ejemplo

Construir un dispositivo basado en una Raspberry Pi que capte WiFi y Bluetooth
Por varias razones. Un objetivo siempre tiene que estar en el dominio del problema, o en un contexto de negocio. Si el problema, por ejemplo, es automatizar los procesos de desarrollo de una empresa que provee soluciones de gesti√≥n de contenidos, un objetivo podr√° ser ‚ÄúCrear configuraciones repetibles que funcionen con una sola orden‚Äù o ‚Äúreducir el tiempo de despliegue de desarrollo a 5 minutos‚Äù o ‚ÄúPoder adaptar soluciones existentes a una nueva soluci√≥n con una semana-persona‚Äù. El objetivo no ser√° nunca

Desarrollar un script de ansible que instale todas las aplicaciones que usamos ahora.
Un objetivo nunca debe formularse como una soluci√≥n espec√≠fica a un problema; es algo que se debe de alcanzar, y justificar, durante el desarrollo de un proyecto. Y nunca debe ser una tarea cerrada. Un TF siempre debe resolver un problema (o parte del mismo), no hacer una tarea.

